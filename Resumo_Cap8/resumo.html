<p style="text-align: center;"><strong> Resumo do Capítulo 8: </strong></p>
<p style="text-align: center;"><strong> Controle de Fluxo Excepcional </strong></p>
<p><strong> Introdução </strong></p>
<p>            O sistema precisa ser capaz de reagir a mudanças no estado do sistema que não são necessariamente relacionadas à execução do programa. Por exemplo, pacotes chegam no adaptador de rede e precisam ser guardados na memória. Programas solicitam dados ao disco e então dormem até serem notificados que os dados estão prontos. Um processo pai que criou um processo filho precisa ser notificado quando o filho terminar.</p>
<p>            Sistemas modernos reagem a essas situações fazendo mudanças abruptas no fluxo de controle. Em geral, essas mudanças abruptas são chamadas de <em> fluxo de controle excepcional </em> (ECF). ECF ocorrem em todos os níveis do sistema.</p>
<p> </p>
<p><strong> 8.1 Exceções </strong></p>
<p>            Exceções são uma forma de ECF que são implementadas parcialmente pelo hardware e parcialmente pelo sistema operacional. Uma vez que elas são implementadas em parte pelo hardware, os detalhes variam de sistema para sistema. No entanto, as ideias básicas são as mesmas para qualquer sistema. Uma exceção é uma mudança abrupta no fluxo de controle em resposta a alguma mudança no estado do processo. Essa mudança no estado é conhecida como um evento.</p>
<p>            Quando o processador detecta que um evento ocorreu, ele faz uma chamada de procedimento indireta (a exceção), através de uma tabela chamada de tabela de exceção, para uma sub-rotina do sistema operacional (manipulador de interrupção) que é especificamente projetada para processar esse tipo particular de evento.</p>
<p> </p>
<p><strong> 8.1.1 Manipulando Exceções </strong></p>
<p>            A cada tipo possível de interrupção em um sistema é atribuído um inteiro maior que zero e único <em> número de exceção </em> . Alguns desses números são atribuídos pelos projetistas do processador, outros são atribuídos pelos projetistas do kernel do sistema.</p>
<p>            Em tempo de boot (quando o computador está sendo ligado ou reiniciado), o sistema operacional aloca e inicializa uma tabela de salto chamada de <em> tabela de exceção </em> , onde cada entrada k contém o endereço do manipulador para a exceção k.</p>
<p>            Em tempo de execução (quando o sistema está executando algum programa), o processador detecta que um evento ocorreu e determina o número k da exceção correspondente. O processador então dispara a exceção fazendo uma chamada indireta, através da entrada k da tabela de exceção, para o manipulador correspondente.</p>
<p>            Uma vez que o hardware tenha disparado a exceção, o resto do trabalho é feito em software pelo manipulador de exceção. Após o manipulador processar o evento, ele opcionalmente retorna para o programa interrompido executando uma instrução especial, que restaura o estado anterior ao controle do processador e os registradores, retorna ao modo de usuário se a exceção interrompeu um programa de usuário, e então retorna o controle ao programa interrompido.</p>
<p> </p>
<p><strong> 8.1.2 Classes de Exceções </strong></p>
<p>            Exceções podem ser divididas em quatro classes: interrupções, traps, faltas e abortos.</p>
<p>            <strong> Interrupções </strong></p>
<p>Interrupções ocorrem assincronamente como resultado de sinais de dispositivos de E/S que são externos ao processador. Interrupções de hardware são assíncronas no sentido de que elas não são causadas pela execução de qualquer instrução particular. Manipuladores de exceção para interrupções de hardware são frequentemente chamados de manipuladores de interrupção.</p>
<p>Depois que a instrução atual termina de executar, o processador percebe que o pino de interrupção foi ativado, lê o número da exceção do barramento de sistema e então chama o manipulador de interrupção apropriado. Quando o manipulador retorna, ele retorna o controle para a próxima instrução.</p>
<p>As classes de exceções restantes ocorrem sincronamente como resultado da execução da instrução atual. Refere-se a essa instrução como <em> faulting instruction. </em></p>
<p><em>             </em> <strong> Traps e Chamadas de Sistema </strong></p>
<p><strong>             </strong> Traps são exceções intencionais que ocorrem como resultado da execução de uma instrução. Assim como manipuladores de interrupção, manipuladores de traps retornam o controle para a próxima instrução. O uso mais importante das traps é fornecer uma interface procedural entre os programas do usuário e o kernel, conhecida como chamada de sistema.</p>
<p>            <strong> Faltas </strong></p>
<p><strong>             </strong> Faltas resultam de condições de erro que o manipulador precisa ser capaz de corrigir. Quando uma falta ocorre, o processador transfere o controle para o manipulador de faltas. Se o manipulador conseguir corrigir o erro, ele retorna o controle para a instrução causadora do erro, que vai ser reexecutada. Caso contrário, o manipulador retorna para uma rotina no kernel que termina o programa que causou a falta.</p>
<p> </p>
<p>            <strong> Abortos </strong></p>
<p><strong>             </strong> Abortos são resultados de erros fatais irreparáveis. Manipuladores de aborto nunca retornam o controle para o programa, ele sempre retorna o controle para uma rotina de aborto que termina o programa.</p>
<p> </p>
<p><strong> 8.2 Processos </strong></p>
<p>            A definição clássica de um processo é uma <em> instância de um programa em execução </em> . Cada programa no sistema roda no contexto de algum processo. O contexto consiste no estado que o programa precisa para rodar corretamente. Esse estado inclui o código do programa e os dados em memória, sua pilha, o conteúdo dos registradores, seu contador de programa, variáveis de ambiente e o conjunto dos descritores de arquivos abertos.</p>
<p>            Cada vez que o usuário roda um programa escrevendo o nome de um arquivo executável no shell, o shell cria um novo processo e então roda o objeto executável no contexto de um novo processo.</p>
<p> </p>
<p><strong> 8.2.1 Fluxo de Controle Lógico </strong></p>
<p>            Um processo dá a cada programa a ilusão de que ele tem uso exclusivo do processador, mesmo que muitos outros programas estejam rodando ao mesmo tempo no sistema. Quando um debbuger é utilizado para fazer a execução passo a passo de um programa, é possível observar uma série de valores do contador de programa (PC) que correspondem exclusivamente às instruções contidas no arquivo executável do programa ou nos objetos linkados dinamicamente ao programa em tempo de execução. Essa sequência de valores do PC é conhecida como <em> fluxo de controle lógico </em> , ou simplesmente <em> fluxo lógico </em> .</p>
<p> </p>
<p><strong> 8.2.2 Fluxos Concorrentes </strong></p>
<p>            Um fluxo lógico que executa em sobreposição de tempo com outro fluxo é chamado de fluxo concorrente e esses dois fluxos rodam concorrentemente. O fenômeno de múltiplos fluxos executarem concorrentemente é conhecido como concorrência. A noção de um processo revezando com outros processos é também chamada de multitasking. Cada período de tempo que um processo executa uma porção do seu fluxo é chamado de time slice.</p>
<p> </p>
<p><strong> 8.2.3 Espaço de Endereçamento Privado </strong></p>
<p>            Cada processo possui seu próprio espaço de endereçamento privado. Esse espaço é privado no sentido de que um byte de memória associado com um endereço particular no espaço geralmente não pode ser lido ou escrito por qualquer outro processo.</p>
<p>            Ainda que o conteúdo de memória associado com cada endereço privado é geralmente diferente, cada espaço possui a mesma organização geral. A porção de baixo do espaço de endereço é reservada para programas de usuário, com seus segmentos de código, dados, heap e pilha. A porção de cima do espaço de endereço é reservada para o kernel, essa parte da memória contém o código, dados e pilha que o kernel utiliza quando executa instruções em nome do processo (e.g., quando o programa executa uma chamada de sistema).       </p>
<p><strong>   </strong></p>
<p><strong> 8.2.5 Mudanças de Contexto </strong></p>
<p><strong>             </strong> O kernel mantém um contexto para cada processo. O contexto é o estado que o kernel precisa para reiniciar um processo preterido. Ele consiste de valores de objetos como os registradores, contador de programa, pilha de usuário, pilha do kernel e várias estruturas de dados do kernel.</p>
<p><strong>             </strong> Em certos pontos durante a execução de um processo, o kernel pode decidir preterir o atual processo e reiniciar um processo previamente preterido. Essa decisão é conhecida como escalonamento e é manipulada por código no kernel, chamado de escalonador. Após o kernel ter escalonado um novo processo para rodar, ele pretere o processo atual e transfere o controle para o novo processo usando um mecanismo chamado de mudança de contexto que primeiro salva o contexto do processo atual, restaura o contexto salvo de algum processo previamente preterido e então passa o controle para o processo restaurado.</p>
<p> </p>
<p><strong> 8.3 Manipulador de Erro de Chamada de Sistema </strong></p>
<p>            Quando funções de nível de sistema do Unix encontram um erro, elas tipicamente retornam -1 e configuram a variável inteira global <em> errno </em> para indicar o que deu errado. Programadores devem sempre checar os erros, mas infelizmente muitos pulam a checagem de erros porque isso incha o código e torna-o difícil de ler.</p>
<p> </p>
<p><strong> 8.4 Controle de Processos </strong></p>
<p><strong> 8.4.1 Obtendo ID dos Processos </strong></p>
<p>Cada processo tem um ID (PID) único, inteiro e positivo (diferente de zero). A função <em> getpid </em> retorna o PID do processo que a chamou. A função <em> getppid </em> retorna o PID do pai do processo chamador (i.e., o processo que criou o processo chamador).</p>
<p> </p>
<p><strong> 8.4.2 Criando e Terminando Processos </strong></p>
<p>De uma maneira geral, um processo pode estar em um dos três seguintes estados:</p>
<ul>
<li><strong> Rodando: </strong> O processo está executando na CPU ou esperando para ser executado e vai eventualmente ser escalonado pelo kernel.</li>
<li><strong> Parado: </strong> A execução do processo está suspensa e este não vai ser escalonado.</li>
<li><strong> Terminado: </strong> O processo está permanentemente parado. Um processo pode parar por um dos três motivos seguintes: receber um sinal cuja ação padrão é terminar o processo, retornar da rotina main, chamar a função <em> exit </em> .</li>
</ul>
<p><strong>   </strong></p>
<p>A função exit termina o processo com um status de saída passado como parâmetro. (Outra maneira de configurar o status de saída é retornar um valor inteiro da rotina main.)</p>
<p>Um processo pai pode criar um novo processo filho chamando a função fork. O novo processo filho criado é quase idêntico ao seu pai. O filho obtém uma cópia idêntica (porém separada) do espaço de memória virtual do processo pai, incluindo segmentos de código e dados, heap, bibliotecas compartilhadas e pilha de usuário. O filho também recebe uma cópia idêntica dos descritores de qualquer arquivo aberto no processo pai. A principal diferença entre o pai e o filho é que eles possuem diferentes PIDs.</p>
<p>A função fork é chamada uma vez, mas retorna duas vezes: uma vez no processo chamador (pai) e uma vez no processo filho. No pai, a função retorna o PID do filho. No filho, a função retorna o valor 0. Uma vez que o PID de um processo é sempre diferente de zero, esse retorno fornece uma maneira precisa para determinar se o programa está executando no pai ou no filho.</p>
<p> </p>
<p><strong> 8.4.3 Coletando Processo Filhos </strong></p>
<p>            Quando um processo termina por alguma razão, ele é mantido em uma espécie de estado terminado até que seja coletado pelo seu pai. Quando o pai coleta o filho terminado, o kernel passa o status de saída do filho para o pai e então descarta o processo terminado. Um processo terminado que ainda não foi coletado é chamado de zumbi.</p>
<p>            Quando um processo pai termina, o kernel faz com que o processo init se torne o pai adotivo dos filhos órfãos. O processo init, que possui o PID 1, é criado pelo kernel durante a inicialização do sistema, nunca termina e é o ancestral de todos os processos. Se um processo pai termina sem coletar seus filhos zumbis, então o kernel faz com que o processo init colete eles. Contudo, programas de longa duração como shells ou servidores devem sempre coletar seus filhos zumbis. Mesmo que os zumbis não estejam rodando, eles continuam consumindo recursos de memória. Um processo espera por suas crianças terminarem ou pararem chamando a função waitpid.</p>
<p> </p>
<p><strong> 8.4.4 Colocando Processos para Dormir </strong></p>
<p>            A função sleep suspende um processo por um período de tempo específico. Essa função retorna zero se período de tempo requisitado já esgotou, ou a quantidade de segundos que restam para dormir caso contrário.</p>
<p> </p>
<p><strong> 8.4.5 Carregando e Rodando Programas </strong></p>
<p>            A função execve carrega e roda um novo programa no contexto do processo atual. A função retorna para o programa chamador apenas se houver algum tipo de erro, então diferente da fork, que é chamada uma vez e retorna duas, execve é chamada uma vez e nunca retorna.</p>
<p> </p>
<p><strong> 8.4.6 Usando fork e execve para Rodar Programas </strong></p>
<p>            Programas como shells do Unix e servidores Web fazem uso pesado das funções fork e execve. Um shell é uma aplicação interativa que roda outros programas em nome do usuário. Um shell realize uma sequência de passos de leitura/avaliação e então termina. O passo de leitura lê a linha de comando do usuário. O passo de avaliação analisa a linha de comando e roda programas em nome do usuário.</p>
<p> </p>
<p><strong> 8.5 Sinais </strong></p>
<p><strong>   </strong></p>
<p><strong> 8.6 Saltos Não-Locais </strong></p>
<p>            O C fornece uma forma de fluxo de controle excepcional a nível de usuário, chamado de salto não-local, que transfere diretamente o controle de uma função para outra atualmente executando sem precisar passar pela sequência normal de chamada-retorno. Saltos não-locais são providos pelas funções setjmp e longjmp.</p>
<p>            A função setjmp salva o ambiente chamador em um buffer, para ser usado posteriormente pela longjmp, e retorna 0. O ambiente chamador inclui o contador de programa, ponteiro de pilha e registradores de propósito geral.</p>
<p>            A função longjmp restaura o ambiente chamador do buffer e então retorna para a chamada mais recente de setjmp que inicializou o buffer.</p>
<p>            Um uso importante de saltos não-locais é possibilitar o retorno imediato de uma chamada de função profundamente aninhada, usualmente como resultado da detecção de algum erro. Se um erro for detectado em uma chamada de função profundamente aninhada, é possível usar uma salto não-local para retornar diretamente para um manipulador de erro de localização conhecida, ao invés de trabalhosamente “desenrolar” a pilha de chamadas.</p>
<p> </p>
<p><strong> 8.7 Ferramentas para Manipulação de Processos </strong></p>
<p>            Os sistemas Linux fornecem ferramentas úteis para monitorar e manipular processos:</p>
<ul>
<li>STRACE: Imprime um rastro de cada chamada de sistema invocada por um programa rodando e seus filhos.</li>
<li>PS: Lista os processos (incluindo zumbis) atuais no sistema.</li>
<li>TOP: Imprime informações sobre o uso de recursos pelos processos atuais.</li>
<li>PMAP: Mostra o mapa de memória de um processo.</li>
<li>/proc: Um sistema de arquivos virtual que exporta o conteúdo de várias estruturas de dados do kernel em um texto ASCII que pode ser lido por programas de usuário.</li>
</ul>
<p> </p>
